## 认识 Docker 
### 简介

如果你经常听到`容器化`一词，应该同时听过 `Docker` 这个词。docker 是容器化技术的实现。

它的基本功能是使同一台服务器上的应用运行环境隔离，即沙箱(sandbox)。`不同于虚拟机`。在 Linux 上，docker 和主机共享内核。

[![](/img/docker_vm.png)](/img/docker_vm.png)

docker 容器内的应用和运行在主机的应用维持在一个运行效率级别，这一点使得它能被大范围推广。

### 组成结构

docker 的基本模型是(C\S)，有以下主要组件：

* docker deamon 作为守护进程，长期提供服务；
* 通过 REST API 与守护程序进行通信并指示其操作的接口；
* 命令行界面 (CLI) 客户端；

[![](/img/docker_engine_components_flow.png)](/img/docker_engine_components_flow.png)

### 运行架构

客户端和守护程序可以运行在不同系统上，`客户端和守护程序的通信`，基于 REST API 使用 UNIX 套接字(sockets)或网络接口(network interface)来实现。

[![](/img/docker_architecture.svg)](/img/docker_architecture.svg)

### 特点

* `轻量`：最小开销，即除了应用本身的开销，docker 额外产生的开销会非常小。
* `可移植性强`：体现在两点上：1、迁移方便。通过 docker 编排的方式，会极大提高迁移效率；2、无缝跨平台。无论是 Windows、Mac 或者 Linux 系统，可以来回迁移；

### 基本概念

#### 镜像 (Image)

应用会被打包成`镜像`，镜像由 docker CLI 工具即可生成。一个镜像可以引用另外一个镜像作为基本镜像，层层包裹。

#### 容器 (Container)

运行镜像时，第一次就会产生容器，后续对于应用的启动、关闭、重启、监控运行状态等等一系列管理的操作，都通过容器来管理。

#### 数据卷 (Data volumns)

docker 的数据持久化。镜像里的所有文件都是`只读的`，如果在运行时对容器内的文件做写操作，docker 会把镜像里的文件复制到容器的可写层(非持久化)，然后编辑文件。当`容器停止运行的时候，可写层的数据全部被清除`。所以想要持久化，就要通过数据卷的方式，把容器的需要持久化的文件位置挂载到主机的文件系统上。那么文件的读写就变成了对主机文件的读写操作。

### 常用文件

* `Dockerfile` ：构建镜像的描述文件，包含了构建镜像所需的指令和说明。一般置于项目`根目录`,通常后缀是`.dockerfile`。
* `docker-compose.yml` ：编排镜像的文件，包含一组构建镜像的命令。也是统一管理镜像启动的一种方式，可以指定`服务启动先后顺序`。

### 网络 (Network)

在单机环境下，容器与容器之前的通信通过`网络桥接`(bridge)实现。docker 默认在主机上建立虚拟桥接，各个服务通信通过同一个桥接来实现通信。在创建容器的时候，可以指定一个自定义网络桥接来实现，网络通信划分。在使用编排来实现时，很简单就实现了。

docker 内部有个`微型dns解析服务`，在指定网络时可以指定一个名称，可以是服务名称。例如：nginx 在反向代理配置指向xxx服务，就可以通过<http://xxx:[端口号>]来访问。

### 仓库 (Repository)

和 npm 包管理方式一样，镜像也是仓库统一存储。docker 镜像都由[Docker Hub](https://hub.docker.com)来管理。如果想要搭建自助(self-service)仓库，直接从官方拉取名为 `registry` 的镜像运行即可。

### 日志 (Log)

运行的容器如果有 `std` 的输出流，默认会被docker 截获。所以主机上，我们直接通过 docker log 命令查看日志。当然如果挂载了 volumn ，容器里的应用可以把日志直接写到主机上。日志访问也可以通过 `REST API` 的方式读取。
