## 数据结构 (三) - 哈希树 (Hash Tree) 
哈希树（通常指 **Merkle 树**）是一种基于哈希函数的树形数据结构，主要用于`大规模数据`的**完整性校验**。

它在`分布式系统`、`区块链`（如比特币和以太坊）、`文件传输验证`、`版本控制系统`（如 Git）等领域有广泛应用。

### **哈希树的结构**

1. **叶子节点**：存储数据块的哈希值。例如，若数据被分成多个块（如文件分块），每个块的哈希值构成叶子节点。
2. **非叶子节点**：每个中间节点是其子节点哈希值的组合哈希。例如，父节点的哈希由其左右子节点的哈希拼接后计算得出。
3. **根节点**（Merkle Root）：树的顶端哈希，代表整个数据集的唯一“指纹”。

![multway-tree.drawio.svg](multway-tree.drawio.svg)

### **哈希树的工作原理**
1. **构建过程**：
   - 将数据分块（如分成 4 个块：D1, D2, D3, D4）。
   - 计算每个块的哈希值（H1=Hash(D1), H2=Hash(D2), ...）。
   - 逐层向上合并哈希：例如，中间节点 Hash(H1+H2) 和 Hash(H3+H4)，最终根节点为 Hash(Hash(H1+H2) + Hash(H3+H4))。

2. **验证数据完整性**：
   - 若想验证某个数据块（如 D2）是否被篡改，只需提供该块的哈希（H2）及其在树中的“路径哈希”（如 H1、Hash(H3+H4) 和根哈希）。
   - 通过逐层计算路径哈希，最终与根哈希对比即可验证。

---

### **哈希树的核心特点**
1. **高效验证**：
   - 验证单个数据块的完整性仅需 $O(\log n)$ 次哈希计算（n 为数据块数），无需下载全部数据。
2. **抗篡改**：
   - 任何数据块的修改都会导致路径哈希直至根哈希的变化，确保全局一致性。
3. **灵活性**：
   - 支持任意数量的数据块（若数量不足，可复制哈希填充）。
4. **空间优化**：
   - 仅需存储根哈希即可验证整个数据集，节省存储成本。

---

### **应用场景**
1. **区块链**：
   - 比特币使用 Merkle 树存储交易，通过根哈希快速验证区块是否包含某笔交易。
2. **文件传输**：
   - BitTorrent 通过 Merkle 树验证下载文件的完整性，避免恶意节点发送错误数据。
3. **版本控制系统**：
   - Git 使用类似结构管理文件版本，确保代码库的一致性。
4. **分布式存储**：
   - IPFS（星际文件系统）利用 Merkle 树标识和验证存储内容。

---

### **示例：验证数据块的流程**
假设有一个 Merkle 树，数据块为 D1-D4，根哈希为 `Root`。验证 D2 是否正确的步骤如下：
1. 计算 D2 的哈希 H2。
2 提供路径哈希：H1（D1 的哈希）、Hash(H3+H4)（D3 和 D4 的父节点哈希）。
3. 计算 Hash(H1 + H2) 得到中间节点哈希。
4. 继续计算 Hash(中间节点 + Hash(H3+H4))，若结果等于 `Root`，则 D2 有效。
